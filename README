NAME
    Nginx - full-featured perl support for nginx

SYNOPSIS
        # nginx-perl.conf
        ... 

        perl_inc      /path/to/lib;
        perl_require  My::App;

        http {
            server {
                location / {
                    perl_handler  My::App::handler;
        ...


        # package My::App;

        use Nginx;

        sub handler {
            my $r = shift;

            $r->main_count_inc;

            ngx_timer 1, 0, sub {
                $r->send_http_header('text/html');
                $r->print("OK\n");

                $r->send_special(NGX_HTTP_LAST);
                $r->finilize_request(NGX_OK);
            };

            return NGX_DONE;
        }

DESCRIPTION
    Nginx with capital *N* is a part of nginx-perl distribution.

    nginx-perl is aimed to support asynchronous functions for embedded perl
    along with other little features to make it nice and usable perl web
    server.

    Currently includes:

        - official old perl API;
        - asynchronous connection (ngx_connector, ngx_reader, ngx_writer);
        - timer (ngx_timer);
        - SSL without cached sessions (ngx_ssl_handshaker);
        - simple resolver (ngx_resolver);
        - access handlers (perl_access);
        - app handlers (perl_app);
        - configuration level eval (perl_eval);
        - init_worker handlers (perl_init_worker);
        - client connection takeover for websockets, etc;

INSTALLATION
    In this distribution perl module is enabled by default, so just
    ./configure should work.

    To build with different perl and SSL support use something like:

        % ./configure \
             --with-http_ssl_module \
             --with-perl=/home/you/perl5/perlbrew/perls/perl-5.14.2/bin/perl
        % make

    There is a working example in hello/. Should be easy to try things out:

        % ./objs/nginx-perl -p hello

    Also nginx-perl can be installed alongside nginx, it is safe to do:

        % make isntall

CONFIGURATION DIRECTIVES
    perl_inc /path/to/lib;
        Works just like Perl's "use lib '/path/to/lib'". Supports only one
        argument, but you can specify it multiple times.

            http {
                perl_inc  /path/to/lib;
                perl_inc  /path/to/myproject/lib;

    perl_require My/App.pm;
        Same as Perl's own "require".

            http {
                perl_inc      /path/to/lib;
                perl_require  My/App.pm;

    perl_init_worker My::App::init_worker;
        Adds a handler to call on worker's start.

            http {
                perl_inc          /path/to/lib;
                perl_require      My/App.pm;

                perl_init_worker  My::App::init_worker;
                perl_init_worker  My::AnotherApp::init_worker;

    perl_handler My::App::handler;
        Sets current location's http content handler (a.k.a. http handler).

            http {
                server {
                    location / {
                        perl_handler My::App::Handler;

    perl_access My::App::access_handler;
        Adds an http access handler to the access phase of current location.

            http {
                server {
                    location / {
                        perl_access My::App::access_handler; 
                        perl_handler My::App::Handler;

    perl_eval '$My::App::CONF{foo} = "bar"';
        Evaluates some perl code on configuration level. Useful if you need
        to configure some perl modules directly fron nginx-perl.conf.

            http {
                perl_eval  '$My::App::CONF{foo} = "bar"';

    perl_app /path/to/app.pl;
        Sets http content handler to the "sub { }" returned from the app.
        Internally does simple "$handler = do '/path/to/app.pl'", so you can
        put your app into @INC somewhere to get shorter path. Additionally
        prereads entire request body before calling the handler. Which means
        there is no need to call $r->has_request_body there.

            http {
                server {
                    location / {
                        perl_app  /path/to/app.pl;

NAMING
        NGX_FOO_BAR  -- constants
        ngx_*r       -- asynchronous functions (creators)
        NGX_VERB     -- flow control constants 
        ngx_verb     -- flow control functions
        $r->foo_bar  -- request object's methods

    Each asynchronous function has an r at the end of its name. This is
    because those functions are creators of handlers with some parameters.
    E.g. ngx_writer creates write handler for some connection with some
    scalar as a buffer.

HTTP REQUEST OBJECT
    All the things from official embedded perl are there and almost
    completely untouched. There are quite a few new methods though:

    $ctx = $r->ctx($ctx)
        Sets and gets some context scalar. It will be useful to get some
        data from access handler for example.

    $r->location_name
        Returns the name of the location.

    $r->root
        Returns the root path.

    $r->main_count_inc()
        Increases value of the internal "r->main->count" by 1 and therefore
        allows to send response later from some other callback.

    $r->send_special($rc)
        Sends response.

    $r->finalize_request($rc)
        Decreases "r->main->count" and finalizes request.

    $r->phase_handler_inc()
        Allows to move to the next phase handler from access handler.

    $r->core_run_phases()
        Allows to break out of access handler and continue later from some
        other callback.

HTTP CONTENT HANDLER
    This is where response should get generated and send to the client.
    Here's how to send response completely asynchronously:

        sub handler {
            my $r = shift;

            $r->main_count_inc;

            ngx_timer 1, 0, sub {
                $r->send_http_header('text/html');
                $r->print("OK\n");

                $r->send_special(NGX_HTTP_LAST);
                $r->finilize_request(NGX_OK);
            };

            return NGX_DONE;
        }

    Notice "return NGX_DONE" instead of "return OK", this is important,
    because it allows to avoid post processing response the old way.

HTTP ACCESS HANDLER
    todo


FLOW CONTROL
    To specify what to do after each callback we can either call some
    function or return some value and let handler do it for us. Most of the
    ngx_* handlers support return value and even optimized for that kind of
    behavior.

    Functions take connection as an argument:

        ngx_read($c)
        ngx_write($c)
        ngx_ssl_handshake($c)
        ngx_close($c)

    Return values only work on current connection:

        return NGX_READ;
        return NGX_WRITE;
        return NGX_SSL_HANDSHAKE;
        return NGX_CLOSE;

    As an example, let's connect and close connection. We will do flow
    control via single "return" for this:

        ngx_connector '1.2.3.4', 80, 15, sub {

            return NGX_CLOSE;
        };

    Now, if we want to connect and then read exactly 10 bytes we need to
    create reader and "return NGX_READ" from connector's callback:

        ngx_connector '1.2.3.4', 80, 15, sub {

            my $c = shift;

            ngx_reader $c, $buf, 10, 10, 15, sub {
                ... 
            };

            return NGX_READ;
        };

    This will be different, if we already have connection somehow:

        ngx_reader $c, $buf, 10, 10, 15, sub {
            ... 
        };

        ngx_read($c);

ERROR HANDLING
    Each ngx_* handler will call back on any error with $! set to some value
    and reset to 0 otherwise. For simplicity EOF considered to be an error
    as well and $! will be set to NGX_EOF in such case.

    Example:

        ngx_reader $c, $buf, 0, 0, sub {

            return NGX_WRITE
                if $! == NGX_EOF;

            return NGX_CLOSE
                if $!;
            ...
        };

ASYNCHRONOUS API
    ngx_timer $after, $repeat, sub { };
        Creates new timer and calls back after $after seconds. If $repeat is
        set reschedules the timer to call back again after $repeat seconds
        or destroys it otherwise.

        Internally $repeat is stored as a refence, so changing it will
        influence rescheduling behaviour.

        Simple example calls back just once after 1 second:

            ngx_timer 1, 0, sub {
                warn "tada\n";
            };

        This one is a bit trickier, calls back after 5, 4, 3, 2, 1 seconds
        and destroys itself:

            my $repeat = 5;

            ngx_timer $repeat, $repeat, sub {
                $repeat--;
            };

    ngx_connector $ip, $port, $timeout, sub { };
        Creates connect handler and attempts to connect to "$ip:$port"
        within $timeout seconds. Calls back with connection in @_
        afterwards. On error calls back with $! set to some value.

        Expects one of the following control flow constants as a result of
        callback:

            NGX_CLOSE
            NGX_READ 
            NGX_WRITE
            NGX_SSL_HANDSHAKE

        Example:

            ngx_connector $ip, 80, 15, sub {

                return NGX_CLOSE
                    if $!;

                my $c = shift;
                ...

                return NGX_READ;
            };

    ngx_reader $connection, $buf, $min, $max, $timeout, sub { };
        Creates read handler for $connection with buffer $buf. $min
        indicates how much data should be present in $buf before the
        callback and $max limits total length of $buf.

        Internally $buf, $min, $max and $timeout are stored as refernces, so
        you can change them at any time to influence reader's behavior.

        Expects one of the following control flow constants as a result of
        callback:

            NGX_CLOSE
            NGX_READ 
            NGX_WRITE
            NGX_SSL_HANDSHAKE

        On error calls back with $! set to some value, including NGX_EOF in
        case of EOF.

            my $buf;

            ngx_reader $c, $buf, $min, $max, $timeout, sub {
        
                return NGX_CLOSE
                    if $! && $! != NGX_EOF;
                ...

                return NGX_WRITE;
            };

CONNECTION TAKEOVER
    It is possible to takeover client connection completely and create you
    own reader and writer on that connection. You need this for websockets
    and protocol upgrade in general.

    There are two methods to support this:

    $r->take_connection()
        "$r->take_connection" initializes internal data structure and
        replaces connection's data with it. Returns *connection* on success
        or *undef* on error.

    $r->give_connection()
        "$r->give_connection" attaches request $r back to its connection.
        Doesn't return anything.

    So, to takeover you need to take connection from the request, tell nginx
    that you are going to finalize it later by calling "$r->main_count_inc",
    create reader and/or writer on that connection, start reading and/or
    writing flow and return NGX_DONE from your HTTP handler:

        sub handler {
            my $r = shift;

            my $c = $r->take_connection()
                or return HTTP_SERVER_ERROR;

            $r->main_count_inc;

                my $buf;

                ngx_reader $c, $buf, ... , sub {

                    if ($!) {
                        $r->give_connection;
                        $r->finalize_request(NGX_DONE);

                        return NGX_NOOP;
                    }

                    ...
                };

                ngx_writer $c, ... , sub {

                    if ($!) {
                        $r->give_connection;
                        $r->finalize_request(NGX_DONE);

                        return NGX_NOOP;
                    }

                    ...
                };

                ngx_read($c);

            return NGX_DONE;
        }

    Once you are done with the connection or connection failed with some
    error you MUST give connection back to the request and finalize it:

        $r->give_connection;
        $r->finalize_request(NGX_DONE);

        return NGX_NOOP;

    Usually you will also need to return NGX_NOOP instead of NGX_CLOSE,
    since your connection is going to be closed within http request's
    finalizer. But it shouldn't cuase any problems either way.

SEE ALSO
    Nginx::Util,

    <http://nginx.net/>, <http://sysoev.ru/nginx/>,
    <http://sysoev.ru/nginx/docs/http/ngx_http_perl_module.html>

AUTHOR
    Igor Sysoev, Alexandr Gomoliako <zzz@zzz.org.ua>

COPYRIGHT AND LICENSE
    Copyright (C) Igor Sysoev

    Copyright 2011 Alexandr Gomoliako. All rights reserved.

    This module is free software. It may be used, redistributed and/or
    modified under the same terms as nginx itself.

